+++
title = "MESA源码分析：概述"
date = 2020-02-19
draft = true


tags = ["kernel", "pci"]
+++

## 架构总体

分析MESA这种大项目一定要把架构理解清楚，这样才能看细节才不会不迷失方向。

MESA的本质，或者说其其形成初期的目的，非常简单：OpenGL。从这里我们可以划清MESA和用户之间的界限，即OpenGL，EGL，OpenGL ES，Vulkan，libgbm等一系列图形API。从用户的角度看，MESA提供了这些库，用户根据API写程序，编译并链接，即可正常使用这些API，达到自己想要的效果。对于熟悉计算机图形学的人来说，这些API本质上就是输入 + 算法 -> 输出，不是什么玄学，自然可以完全通过软件进行实现。事实上，MESA提供了完全的软件实现作为fallback。

但是我们实际上知道MESA是提供了硬件实现的，也就是说MESA实质上是一系列GPU硬件的用户态驱动集合。从实现原理上来说，MESA提供的`libGL.so`等库可以根据系统环境选择相应的实现，在没有检测到可用硬件实现的情况下fallback回纯软件实现。但是GPU本身是一个非常复杂的硬件，它的软件栈经过了好几次大的变革，需要了解点历史，才能更好理解现在的实现。

最初，X11时代下，X11是被认为需要管理图形硬件的，所以相关的驱动都围绕X11进行，也就是X11有比较复杂的DDX驱动。GPU的用户态驱动大部分围绕X11编写，所以对于MESA，libGL最直观的实现方式就是使用一个特殊的协议，将应用程序对libGL的调用转发给Xorg服务器，再将所得结果进行返回。这个协议就是GLX协议。这样的实现固然维护了X11服务器总管图形硬件的设计，但随着图形硬件性能的发展已经无法满足性能需求了。开发者意识到，这样转发的开销实际上怎么优化都是无法忽略的，这使得该架构需要被新的架构替代掉。

新架构被称作DRI（Direct Rendering Infrastructure），之所以称作直接（Direct），是因为摒弃掉了原先使用GLX协议进行转发的行为。此时，在新架构下，原有的由X11服务器对GPU硬件全权管理的模式被抛弃，GPU被内核相应驱动接管与控制。此时用户态可以公平的对硬件资源进行请求，称作用户态client。在这个架构下，MESA对libGL的实现发生了改变，用户态通过链接并调用libGL的API，可以直接对GPU进行访问与调用，实现相关渲染。而Xorg Server的角色发生了改变，从libGL的角度来看，Xorg Server与其他用户态进程无异，只不过Xorg Server可以通过一个被称作KMS的API控制显示控制器，将一个特定的buffer输出到屏幕上。

由于MESA需要支持大量的硬件，那么对于每一个硬件，都要实现一个被称作DRI驱动的用户态GPU驱动。libGL可以根据系统环境，动态的加载特定的DRI驱动。从这里开始，用户态和内核的界限是比较模糊的。内核DRM子系统中，与用户态相关比较稳定的API也就是KMS了。对于一款GPU，其涉及到3D渲染的内核态驱动与用户态驱动之间没有明显的界限，亦即没有公共使用的接口。

## 需要分析的抽象

* DRI驱动接口
* gallium3D
* 内核DRM
* winsys

## 架构分析

昨天看了一个igalia的大佬对MESA的介绍性讲解，我认为与我自己理解的是比较符合的。现在将我自己的理解记录如下：

* MESA的直接目的是实现opengl与vulkan API，也就是应用程序并不是直接调用MESA，而是直接调用opengl的libGL，或者vulkan相关的库函数。这就是另一个标准了，这里不讨论。
* 为了实现这样的API，MESA的实现做了层层抽象。首先就是被称作state tracker的部分，这个部分本质上就是对opengl标准的通用实现。简单来说，就是抽象出了共通的部分，使得后端可以自行实现不同的部分。目前，我们研究的后端最主要的就是DRI后端，事实上，还有旧的GLX后端等等。GLX后端的用途提一嘴，这是旧时代的产物，由于X11 server总领全局，全权控制图形硬件，所以人们设计了GLX协议，使得应用程序对libGL的调用可以被GLX协议转发给X11 Server，由X11 Server处理后再返回结果。
* GLX这套机制在GPU越来越复杂，越来越高性能的情况下不适用。因为这个转发的成本无法忽视，因此人们设计了DRI机制，其与GLX本质的区别，就是应用程序不再依靠X11管理图形硬件，而是可以直接使用libGL（即MESA）访问图形硬件，完成FB的渲染，再提供compositor进行合成操作。
* 这套机制的内核实现部分被称作DRM（Direct Rendering Manager）。之所以被称作manager，是因为原来的模型发生了改变，显卡硬件不再是由X11直接管理的了，而是由内核DRM管理。同一时刻下，用户态可能有多个client对其进行访问，因此，管理与分配整个硬件的资源则成为了内核DRM模块的主要工作。事实上，通过MESA提供的libGL API对图形硬件进行访问时，整个线程就变成了这样一个用户态的client。
* 这里，我们粗略将图形硬件分成两个模块：显示控制器和3D pipeline。对于显示控制器，目前的软件演进情况是，原先由X11实现的部分被彻底放到内核中，通过被称作KMS的API进行管理。用户态程序可以直接打开DRM设备，并调用KMS API，实现对显示器的输出管理。而3D pipeline的实现则相当复杂，这是由于显示控制器的实现各家都是大同小异，没有本质的区别，适用一套公共的API可以实现，但是3D pipeline的实现则各家都有各家的做法，灵活性相当高。因此，3D pipeline的驱动更倾向于在用户态实现，内核仅仅实现简单的command ring等管理操作。事实上，这一部分被称作MESA DRI驱动。
* MESA DRI驱动实际上也相当灵活，因此MESA的开发者设计并实现了另一套框架，被称作gallium，专门用于实现DRI驱动。这个框架的本质是抽象出图形硬件的通用操作，驱动开发者只需要实现特定callback，完成图形硬件功能的填充，然后gallium框架则会自行实现DRI与gallium回调函数中间的部分，实现一个DRI驱动。
* 最后的最后，我们避而不提的一个重要部分就是MESA中的编译器实现。OpenGL Core Profile中，大部分可编程的部分是通过shader实现的，也就是MESA需要实现对shader的编译。因此MESA中有完整的GLSL shader实现，这其中定义了多种IR。由于编译器话题的探讨比较沉重，以后在说吧。



事实上，我对MESA的分析应该换一种思路，我现在认为，我的分析应该直接分析抽象的部分，因为现在没有比较好的硬件细节让我分析。事实上，我目前认为比较好的下手点是DRI与gallium框下直接的通用部分。这其中一个比较明确的界限就是gallium框架底层的回调函数与DRI的接口函数。把这两个界限把握好，我们能正确下手了。
