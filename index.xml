<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>crab2313's blog</title><link>crab2313.github.io/</link><description>Recent content on crab2313's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 26 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="crab2313.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>DRM显示框架分析</title><link>crab2313.github.io/post/drm/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/drm/</guid><description>真的没有想到真的有人能看到这篇东西，所以我准备抽出时间把这个东西整理完。本文是我阅读内核DRM子系统的一些随笔，其目的是记录我对内核代码的阅</description></item><item><title>路线指引</title><link>crab2313.github.io/post/roadmap/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/roadmap/</guid><description>今天和大佬面谈，收获非常大。我觉得我有必要立即记录下来，形成日后的学习路线。首先大佬指出了我自身的不足： 没有做自己的东西。也就是说，我所有的</description></item><item><title>Linux内核组播包接收流程分析</title><link>crab2313.github.io/post/multicast/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/multicast/</guid><description>本文直接分析组播接收的流程细节。由于工作需要，暂且分析2.6.32内核的相关细节，并将分析文档记录于此。 驱动层 TCP/IP协议栈是典型的ti</description></item><item><title>Mutter实现分析：Atomic Modesetting</title><link>crab2313.github.io/post/mutter-a-kms/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/mutter-a-kms/</guid><description>首先注意一个名字上的区分，一开始看代码的人可能会对命名有疑惑。在Jonas的设计中，整个KMS相关代码分为两个上下文：main和impl。m</description></item><item><title>Linux内核在RISC-V架构下的内存屏障与原子操作</title><link>crab2313.github.io/post/riscv-atomic-barrier-bitops/</link><pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/riscv-atomic-barrier-bitops/</guid><description>内存一致性模型是一个体系结构中至关重要的一部分，本质上为软件与硬件之间的契约。软件开发人员可以从内存一致性模型中得知硬件进行内存操作时可能的</description></item><item><title>Linux内核在RISC-V架构下的setup_arch与异常处理</title><link>crab2313.github.io/post/riscv-setup-arch-exception/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/riscv-setup-arch-exception/</guid><description>在分析完Linux内核在RISC-V架构下的启动流程后，我们分析Linux下与RISC-V相关的架构相关实现。很明显，这类知识都是非常零散的</description></item><item><title>Linux内核在RISC-V架构下的构建与启动</title><link>crab2313.github.io/post/riscv-build-and-boot/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/riscv-build-and-boot/</guid><description>本文分析RISC-V的linux移植是如何完成的，并给出具体的入手方法，希望对后来者有所启发。RISC-V是一个比较新的体系结构，截至目前已</description></item><item><title>TTM内存分配器分析</title><link>crab2313.github.io/post/ttm/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/ttm/</guid><description>TTM 本文结合QXL内的实现分析内核DRM框架中提供的TTM内存管理器。 BO BO是Buffer Object的缩写，与Buffer是有区别的。个人理</description></item><item><title>SMMU内核驱动分析</title><link>crab2313.github.io/post/smmu/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/smmu/</guid><description>IOMMU核心框架层 IOMMU核心框架是管理IOMMU设备的一个通过框架，IOMMU设备通过实现特定的回调函数并将自身注册到IOMMU核心框</description></item><item><title>PCI驱动框架分析</title><link>crab2313.github.io/post/pci/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/pci/</guid><description>PCI 分析流程： 硬件文档 PCI框架核心层 PCI框架热插拔 vfio iommu vfio接口层与用户态使用cloud-hypervisor 一共十一万行代码。 从ACP</description></item><item><title>kdump工作机制分析</title><link>crab2313.github.io/post/kdump/</link><pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/kdump/</guid><description>kdumpctl kdumpctl是一个shell脚本，用于查看当前kdump的状态和进行kdump相关操作。kdumpctl的入口是main函数，从中可以</description></item><item><title>Linux设备模型：bus与driver</title><link>crab2313.github.io/post/bus-and-driver/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/bus-and-driver/</guid><description>bus &amp;amp; driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k</description></item><item><title>Linux设备模型：kobject与uevent</title><link>crab2313.github.io/post/kobject-and-uevent/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/kobject-and-uevent/</guid><description>kobject 1 2 3 4 5 6 7 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); }; 1 2 3 4 5 6 7 8 struct kobj_ns_type_operations { enum kobj_ns_type type; bool (*current_may_mount)(void); void *(*grab_current_ns)(void); const void *(*netlink_ns)(struct sock *sk); const void *(*initial_ns)(void); void (*drop_ns)(void *); }; 1 2 3 4 5 6</description></item><item><title>USB Hub驱动分析</title><link>crab2313.github.io/post/usb-hub/</link><pubDate>Tue, 27 Feb 2018 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/usb-hub/</guid><description>USB hub框架分析 USB hub框架是usbcore模块里的一个大头5000行代码（5分之一）。同时，USB hub本身在USB协议中又是一个非常重要</description></item><item><title>inode权限检查</title><link>crab2313.github.io/post/inode-permission/</link><pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/inode-permission/</guid><description>inode_permission函数 inode_permission函数用于对inode进行权限检查，我们传给其一个mask参数，这个参数是</description></item><item><title>eventfd在内核中的实现</title><link>crab2313.github.io/post/eventfd/</link><pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/eventfd/</guid><description>eventfd是一个利用匿名文件描述符实现“等待/通知”通信机制的一种方式。它比较方便的一点是，eventfd不仅可以实现用户态与用户态之间</description></item><item><title>Floyd循环检测算法</title><link>crab2313.github.io/post/floyd-cycle-detection/</link><pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate><guid>crab2313.github.io/post/floyd-cycle-detection/</guid><description>循环检测问题 在研究抽象代数的时候，很多教材都是从欧拉研究的循环群入手的，比如这本《Advanced Modern Algebra》。 当然，直接讨论数学有些</description></item></channel></rss>