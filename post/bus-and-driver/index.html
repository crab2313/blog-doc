<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Linux设备模型：bus与driver - crab2313's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="crab2313"><meta name=description content="bus &amp;amp; driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k"><meta name=keywords content="blog,kernel"><meta name=generator content="Hugo 0.82.0 with theme even"><link rel=canonical href=crab2313.github.io/post/bus-and-driver/><link rel=apple-touch-icon sizes=180x180 href=/crab2313.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/crab2313.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/crab2313.github.io/favicon-16x16.png><link rel=manifest href=/crab2313.github.io/manifest.json><link rel=mask-icon href=/crab2313.github.io/safari-pinned-tab.svg color=#5bbad5><link href=/crab2313.github.io/sass/main.min.39a3e01cac9473be1356f3572fcfe34b2e363efabad244a99a40f28a812c837e.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Linux设备模型：bus与driver"><meta property="og:description" content="bus & driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k"><meta property="og:type" content="article"><meta property="og:url" content="crab2313.github.io/post/bus-and-driver/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-04-28T00:00:00+00:00"><meta property="article:modified_time" content="2018-04-28T00:00:00+00:00"><meta itemprop=name content="Linux设备模型：bus与driver"><meta itemprop=description content="bus & driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k"><meta itemprop=datePublished content="2018-04-28T00:00:00+00:00"><meta itemprop=dateModified content="2018-04-28T00:00:00+00:00"><meta itemprop=wordCount content="3116"><meta itemprop=keywords content="kernel,driver,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux设备模型：bus与driver"><meta name=twitter:description content="bus & driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/crab2313.github.io/ class=logo>crab2313's blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=crab2313.github.io/><li class=mobile-menu-item>Home</li></a><a href=crab2313.github.io/post/><li class=mobile-menu-item>Archives</li></a><a href=crab2313.github.io/tags/><li class=mobile-menu-item>Tags</li></a><a href=crab2313.github.io/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/crab2313.github.io/ class=logo>crab2313's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=crab2313.github.io/>Home</a></li><li class=menu-item><a class=menu-item-link href=crab2313.github.io/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=crab2313.github.io/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=crab2313.github.io/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Linux设备模型：bus与driver</h1><div class=post-meta><span class=post-time>2018-04-28</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#bus--driver>bus & driver</a><ul><li><a href=#subsys_private>subsys_private</a></li><li><a href=#bus_register>bus_register</a></li><li><a href=#bus的三个属性>bus的三个属性</a></li><li><a href=#subsys_system_register>subsys_system_register</a></li><li><a href=#bus通知机制>bus通知机制</a></li><li><a href=#bus_add_device>bus_add_device</a></li><li><a href=#bus_add_driver>bus_add_driver</a></li><li><a href=#driver_register>driver_register</a></li></ul></li></ul></nav></div></div><div class=post-content><h1 id=bus--driver>bus & driver</h1><p>bus core的实现在<code>driver/base/bus.c</code>中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_kset（name为bus）和system_kset（name为system）。初始化过程这么简单的话bus注册的工作应该就会比较复杂了。</p><h2 id=subsys_private>subsys_private</h2><p>为了隐藏bus core内部的状态，每个bus_type都保存一个指向subsys_private结构体的指针，这个数据结构只能由bus core中进行操作。其中subsys即为表示该bus的kset，subsys中还将放置另外两个kset，即结构体中的devices_kset和drivers_kset，很明显这两个kset用于存放驱动和设备。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>subsys_private</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=n>kset</span> <span class=n>subsys</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>kset</span> <span class=o>*</span><span class=n>devices_kset</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>list_head</span> <span class=n>interfaces</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>mutex</span> <span class=n>mutex</span><span class=p>;</span>

        <span class=k>struct</span> <span class=n>kset</span> <span class=o>*</span><span class=n>drivers_kset</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>klist</span> <span class=n>klist_devices</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>klist</span> <span class=n>klist_drivers</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>blocking_notifier_head</span> <span class=n>bus_notifier</span><span class=p>;</span>
        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>drivers_autoprobe</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>bus_type</span> <span class=o>*</span><span class=n>bus</span><span class=p>;</span>

        <span class=k>struct</span> <span class=n>kset</span> <span class=n>glue_dirs</span><span class=p>;</span>
        <span class=k>struct</span> <span class=n>class</span> <span class=o>*</span><span class=n>class</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><h2 id=bus_register>bus_register</h2><p>这个函数应该是bus core最广为人知的入口了，可以将一个bus_type注册到内核的bus子系统中。抛开大部分内存申请等常规初始化过程不谈，函数中首先创建了一个subsys_private对象，并将其的指针保存到bus->p中。随即将bus->p->kobj的name设置为bus->name，并将这个kset加入到前面提到的bus_kset中。顺便一提表示一个bus的kset使用bus_ktype作为其类型，后面详细说明。</p><p>接下来函数调用kset_create_and_add创建devices_kset和drivers_kset，并将其加入表示bus的kset。在做完以上工作后，函数向表示该bus的kset中加入了三个属性：</p><ul><li>uevent</li><li>drivers_autoprobe</li><li>drivers_probe</li></ul><p>而传入bus_register的bus_type->bus_group也会被当作attribue_group注册到bus对应的sysfs文件夹中。</p><h2 id=bus的三个属性>bus的三个属性</h2><p>前面提到表示bus的kset中加入了三个属性，这里列出他们的定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=nf>BUS_ATTR</span><span class=p>(</span><span class=n>uevent</span><span class=p>,</span> <span class=n>S_IWUSR</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>bus_uevent_store</span><span class=p>);</span>
<span class=k>static</span> <span class=nf>BUS_ATTR</span><span class=p>(</span><span class=n>drivers_probe</span><span class=p>,</span> <span class=n>S_IWUSR</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>store_drivers_probe</span><span class=p>);</span>
<span class=k>static</span> <span class=nf>BUS_ATTR</span><span class=p>(</span><span class=n>drivers_autoprobe</span><span class=p>,</span> <span class=n>S_IWUSR</span> <span class=o>|</span> <span class=n>S_IRUGO</span><span class=p>,</span>
                <span class=n>show_drivers_autoprobe</span><span class=p>,</span> <span class=n>store_drivers_autoprobe</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>这三个属性会作为文件存在于sysfs中。首先drivers_autoprobe是比较好理解的，subsystem_private中保存了一个drivers_autoprobe值，如果为true则进行驱动与设备的自动匹配。向sysfs中一个bus对应文件夹下的drivers_autoprobe写入1或者0则可以改变它的值。</p><p>uevent则作为一个调试uevent的接口，通过向该文件写入对应的信息，内核可以调用kobject_synth_uevent函数生成对应的uevent事件。可以直接使用echo进行该操作，而写入字符串的格式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>ACTION [UUID] [KEY1=VALUE1] [KEY2=VALUE2] ...
</code></pre></td></tr></table></div></div><p>这里写入的环境变量会以SYNTH_ARG_KEY=VALUE的形式出现在uevent信息中。最后一个drivers_probe属性可以让总线重新为一个没有匹配到驱动的设备进行驱动匹配。将想要进行匹配的设备名写入到drivers_probe即可进行该操作。</p><h2 id=subsys_system_register>subsys_system_register</h2><p>文档里说这个接口不要在新代码中用，接口本身只做兼容性用途。前面提到了一个system_ket，这里需要提一下它是如何初始化的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c>        <span class=n>system_kset</span> <span class=o>=</span> <span class=n>kset_create_and_add</span><span class=p>(</span><span class=s>&#34;system&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>devices_kset</span><span class=o>-&gt;</span><span class=n>kobj</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>可以猜到devices_kset应该<code>/sys/devices</code>文件夹，也就是说system_ket的路径为<code>/sys/devices/system</code>。首先函数注册了一个假设备，名字与传入的bus_type一致，然后将这个设备的parent设置成system_kset.kobj，并将bus_type->dev_root设置刚才注册的那个假设备。总线新注册设备时会将其parent设置成dev_root，因此使用subsys_system_register函数注册的总线（子系统）会被放到<code>/sys/devices/system/&lt;bus-name>/</code>底下。我们常见的子系统有clocksource，cpu，memory等等。</p><h2 id=bus通知机制>bus通知机制</h2><p>subsys_private中有一个bus_notifier，他是一个blocking_notifier。内核各个子系统之间为了高效进行信息传递使用注册监听机制，称作notifier。这里使用的是blocking_notifier，其特点是发送事件是可以阻塞。当然，bus core负责事件的发送，所以我们最多进行事件的监听。</p><h2 id=bus_add_device>bus_add_device</h2><p>一个bus从逻辑上来讲是要管理设备和驱动的，所以应该提供对应的接口将总线或者驱动加入到bus中来。但是事实上，bus_add_device并没有被export出来，也就是说内核模块是不能调用这个函数的。</p><p>每个设备在创建时都应将其bus指针设置成其对应的bus_type，所以函数第一步做的就是将其bus_type取出来。接下来所作大部分是sysfs相关的处理：</p><ul><li>调用device_add_groups将bus->dev_groups加入到设备中去，翻译成白话就是在设备对应的sysfs文件夹中加入总线自己定义的一些属性。</li><li>调用sysfs_create_link创建从设备到bus->p->devices_kset的符号连接，也就是在sysfs中建立从设备文件夹到bus/devices文件夹下的符号连接。</li><li>调用sysfs_create_link在设备文件夹内创建一个名为subsystem的符号连接，该链接指向bus文件夹。</li></ul><p>最后将设备挂入bus维护的设备列表中。</p><h2 id=bus_add_driver>bus_add_driver</h2><p>类似于device，driver也有一个bus指针指向它应该属于的bus_type。传进来的device_driver本身没有kobject，bus_add_driver会创建一个嵌入了kobject的driver_private结构体并将其保存在device_driver中。很明显，这个被创建的kobject的kset指针需要被设置成bus->p->drivers_kset，即其注册入sysfs时会被放入<code>/sys/bus/&lt;bus-name>/drivers/</code>文件夹中。</p><p>如果bus的drivers_autoprobe为true，则bus_add_driver会尝试进行设备匹配。与bus设备一样，driver也被加入了uevent属性，也就是driver对应的文件夹下也有uevent文件，向其写人对应的命令也能触发uevent事件。类似于device，bus->drv_groups保存的attribute_group向该bus中的driver追加了bus预先设置好的属性。</p><p>如果device_driver里的suppress_bind_attrs不为true，则bus_add_driver应该向其追加两个属性：bind和unbind。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=nf>DRIVER_ATTR_WO</span><span class=p>(</span><span class=n>unbind</span><span class=p>);</span>
<span class=k>static</span> <span class=nf>DRIVER_ATTR_WO</span><span class=p>(</span><span class=n>bind</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>这个文件的作用是相反的：将设备名写入在一个driver文件夹下的unbind文件时，会使driver释放掉该设备，bind文件则会使driver试图匹配该设备。最后可以看一下这一行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c>        <span class=n>module_add_driver</span><span class=p>(</span><span class=n>drv</span><span class=o>-&gt;</span><span class=n>owner</span><span class=p>,</span> <span class=n>drv</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>该函数的主要作用为更新引用计数，并创建两个符号链接：driver文件夹下的module，<code>&lt;module>/drivers/</code>文件夹下的driver。</p><h2 id=driver_register>driver_register</h2><p>这个函数其实没有做什么事情，大部分工作都由bus承担了。函数首先调用driver_find查找bus上是否已经有了同名驱动，如果有则报错退出。接下来调用bus_add_driver将其注册到bus中去。如果device_driver->groups不为NULL，则将其添加到自身的属性中。最后触发一个ADD类型的uevent事件。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>crab2313</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2018-04-28</span></p></div><footer class=post-footer><div class=post-tags><a href=/crab2313.github.io/tags/kernel/>kernel</a>
<a href=/crab2313.github.io/tags/driver/>driver</a></div><nav class=post-nav><a class=prev href=crab2313.github.io/post/kdump/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">kdump工作机制分析</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=crab2313.github.io/post/kobject-and-uevent/><span class="next-text nav-default">Linux设备模型：kobject与uevent</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:crab2313@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/crab2313 class="iconfont icon-github" title=github></a><a href=https://gitlab.com/crab2313 class="iconfont icon-gitlab" title=gitlab></a><a href=https://space.bilibili.com/1310103 class="iconfont icon-bilibili" title=bilibili></a><a href=crab2313.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>crab2313</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/crab2313.github.io/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>